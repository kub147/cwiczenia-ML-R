---
title: "Zadanie 4" 
author: Jakub Wilk
date: 2024-10-23
format:   
  html:    
    toc: true    
    toc-depth: 3    
    toc-location: right    
    toc-title: Spis Treści    
    number-sections: true    
    number-depth: 3    
    html-math-method: katex    
    code-tools: true    
    code-block-bg: true    
    code-fold: show    
    code-summary: "Show and hide code"    
    link-external-icon: true    
    link-external-newwindow: true    
    smooth-scroll: true    
    self-contained: true 
    theme:         
      dark: solar 
      light: flatly    
    fontsize: 1.0em    
    linestretch: 1.3    
    fig-align: center
execute:   
  echo: true  
  error: false  
  warning: false  
  output: true
editor_options: 
  chunk_output_type: console
---

# Przygotowanie środowiska
```{r}
library(tidymodels) 
library(skimr) 
library(vip)
library(GGally) 
library(openair)
library(DT) 
library(dplyr)
library(ranger)
library(yardstick)
tidymodels_prefer()

# Ustawienie ziarna losowości
set.seed(123)
```

# Wczytanie i przygotowanie danych
```{r}
# Wczytanie danych z openair
ozone_data <- mydata |> 
  selectByDate(year = 2002) |> 
  na.omit()

# Klasyfikacja wartości O3 na dwie kategorie
ozone_data <- ozone_data |>  
  mutate(ozone = cut(
    o3,
    breaks = c(-0.1, 10, 53),
    labels = c("Low", "High")
  ))

# Check correlation
ozone_data |> 
  select_if(is.numeric) |> 
  cor(use = "complete.obs") |> 
  as.data.frame() |> 
  select(o3)
```


```{r}
set.seed(222)
data_split <- initial_split(data=ozone_data, prop = 0.75, strata = ozone)
train_set <- training(data_split)
test_set <- testing(data_split)

ggplot(train_set, aes(x = date, y = o3)) + 
  geom_line() + 
  theme_minimal()
```



# Ćwiczenie 4.6 - Optymalizacja drzewa decyzyjnego

## Przygotowanie modelu i przepisu (recipe)
```{r}
hyper_spec <- 
  rand_forest(mtry = tune(),
              min_n = tune(),
              trees = 1000) |>
  set_engine("ranger",
  num.threads=parallel::detectCores() - 1,
  importance = "impurity") |> 
  set_mode("classification")

```

## Przygotowanie siatki parametrów
```{r}
# Stworzenie siatki parametrów dla lasu losowego
param_grid <- grid_regular(
  mtry(range = c(1, 10)),
  min_n(range = c(1, 10)),
  levels = 5
)
print("Siatka parametrów dla lasu losowego:")
param_grid
```

## Walidacja krzyżowa i dostrajanie
```{r}
# Przygotowanie foldów CV
set.seed(234)
cv_folds <- vfold_cv(data=train_set, v=10, repeats = 5)


# przepis
ozone_recipe <- 
  recipe(ozone ~ ., data = train_set) |> 
  update_role(o3, wd, date, pm10, pm25, so2, co, no2, new_role = "ID") |> 
  step_BoxCox(ws, nox, no2) |> 
  step_date(date, features = c("month")) |> 
  step_time(date, features = c("hour")) |>
  step_mutate(date_hour = as.factor(date_hour)) |>  
  step_dummy(all_nominal_predictors()) |> 
  step_zv()


ozone_recipe |> summary()

```



```{r}
# workflow
basic_rf_workflow <- 
  workflow() |> 
  add_model(hyper_spec) |> 
  add_recipe(ozone_recipe)
```


## Finalizacja modelu drzewa
```{r}
# Resampling
rf_fit_cv <- 
  basic_rf_workflow |> 
  fit_resamples(cv_folds)
```


## Hyperparametry

```{r}
tuning_metrics  <- 
  yardstick::metric_set(
    accuracy,
    mcc,
    npv,
    roc_auc
  )

tuned_results <- basic_rf_workflow |> 
  tune_grid(
    resamples=cv_folds,
    grid=param_grid,
    metrics=tuning_metrics
  )
```

```{r}
tuned_results |> 
  collect_metrics() |> 
  mutate(mtry = factor(mtry)) |>
  ggplot(aes(min_n, mean, color = mtry)) +
  geom_line(linewidth = 1.5, alpha = 0.6) +
  geom_point(size = 2) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10(labels = scales::label_number()) +
  scale_color_viridis_d(option = "plasma", begin = .9, end = 0)
```

## najlepszy model 
```{r}
best_params <- tuned_results |> 
  select_best(metric="accuracy")

final_rf_workflow <- basic_rf_workflow |> 
  finalize_workflow(best_params)

final_fit <- 
  final_rf_workflow |> 
  last_fit(split=data_split)

# Evaluate predictions
final_fit |> 
  collect_predictions() |> 
  roc_curve(truth = ozone, .pred_Low) |> 
  autoplot()
```


```{r}
final_fit |> 
  extract_workflow() |> 
  extract_fit_parsnip() |>
  vip()
```

```{r}
final_metrics <- bind_rows(
  final_fit |> 
    collect_metrics() |> 
    filter(.metric == "accuracy" | .metric == "roc_auc") |>
    mutate(.approach = "final_fit")
)

final_metrics |> knitr::kable(digits = 3)
```